	/**
	 * QEMU stack corruption reproducer found during DMACU development
	 * (aka. "smashing the stack on your host's qemu from within the virtual cpu running on the dma controller of your emulator")
	 *
	 * Copyright (c) 2021 Johannes Winter
	 *
	 * This file is licensed under the MIT License. See LICENSE in the root directory
	 * of the project for the license text.
	 *
	 * Typical build + simulation:
	 *   arm-none-eabi-gcc -o exploit.elf -nostartfiles -Ttext=0 -DQEMU_BOOTSTRAP=1 dmacu_pl080.S dmacu_exploit_qemu.S
	 *   qemu-system-arm -M versatilepb -kernel exploit.elf -semihosting  -serial stdio
	 */

	/* Emits a generic DMACU instruction */
	.macro DMACU.INST op, rz, rb, ra
	.byte (\ra), (\rb), (\rz), (\op)
	.endm

	/* Emits a DMACU instruction with 16 bit immediate */
	.macro DMACU.OP1.IMM16 op, rz, imm16
	DMACU.INST (\op), (\rz), ((\imm16) >> 8) & 0xFF, (\imm16) & 0xFF
	.endm

	/* Emit an absolute (program base relative) branch instrcution */
	.macro DMACU.INST.JMP.ABS op, rz, tgt
	DMACU.OP1.IMM16 (\op), (\rz), ((\tgt) - DMACU_Code)
	.endm


	/* Emit a relative branch instrcution */
	.macro DMACU.INST.BRANCH.REL op, rz, rb, tgt
.LDMACU_JmpRel_Anchor\@:
	DMACU.INST (\op), (\rz), (\rb), ((\tgt) - .LDMACU_JmpRel_Anchor\@)
	.endm

	/*
	 * NOP       - No Operation
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x00 | (0)  | (0)  | (0)  |
	 * +------+------+------+------+
	 */
	.macro DMACU.NOP
	DMACU.INST 0x00, 0, 0, 0
	.endm

	/*
	 * MOV rZ, #imm8 - Move to register from 8-bit immediate
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x01 | rZ   | (0)  | imm8 |
	 * +------+------+------+------+
	 */
	.macro DMACU.MOV.IMM8 rZ, imm8
	DMACU.INST 0x01, (\rZ), 0, (\imm8)
	.endm

	/*
	 * MOV rZ+1:rZ, #imm16 - Move to register pair from 16-bit immediate
	 *
	 *  31  24     16             0
	 * +------+------+-------------+
	 * | 0x02 | rZ   |       imm16 |
	 * +------+------+-------------+
	 */
	.macro DMACU.MOV.IMM16 rZ, imm16
	DMACU.OP1.IMM16 0x02, (\rZ), (\imm16)
	.endm

	/*
	 * MOV2 rZ+1:rZ, rB:rA - Move from register pair to register pair
	 * MOV  rZ, rA         - (Pseudo-Instruction) Move from register to register (if rB=rZ+1)
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x03 |  rZ  | rB   |  rA  |
	 * +------+------+------+------+
	 */
	.macro DMACU.MOV2 rZ, rB, rA
	DMACU.INST 0x03, (\rZ), (\rB), (\rA)
	.endm

	.macro DMACU.MOV rZ, rA
	DMACU.MOV2 (\rZ), ((\rZ)+1), (\rA)
	.endm

	/*
	 * ADD rZ, rB, #imm8               - Add register and 8-bit immediate
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x04 |  rZ  | rB   | imm8 |
	 * +------+------+------+------+
	*/
	.macro DMACU.ADD.IMM8 rZ, rB, imm8
	DMACU.INST 0x04, (\rZ), (\rB), (\imm8)
	.endm

	/*
	 * ACY rZ, rB, #imm8               - Generate carry from add with 8-bit immediate
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x05 |  rZ  | rB   | imm8 |
	 * +------+------+------+------+
	 */
	.macro DMACU.ACY.IMM8 rZ, rB, imm8
	DMACU.INST 0x05, (\rZ), (\rB), (\imm8)
	.endm

	/*
	 * ADD rZ, rB, rA                  - Add two registers
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x06 |  rZ  | rB   | rA   |
	 * +------+------+------+------+
	 */
	.macro DMACU.ADD rZ, rB, rA
	DMACU.INST 0x06, (\rZ), (\rB), (\rA)
	.endm

	/*
	 * ACY rZ, rB, rA                 - Generate carry from add with 8-bit registers
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x07 |  rZ  | rB   | rA   |
	 * +------+------+------+------+
	 */
	.macro DMACU.ACY rZ, rB, rA
	DMACU.INST 0x07, (\rZ), (\rB), (\rA)
	.endm

	/*
	 * JMP #imm16                    - Jump absolute
	 *
	 *  31  24 23                 0
	 * +------+------+-------------+
	 * | 0x08 |  (0) | imm16       |
	 * +------+------+-------------+
	 */
	.macro DMACU.JMP tgt
	DMACU.INST.JMP.ABS 0x08, 0x00, (\tgt)
	.endm

	/*
	 * JMP rB:rA                    - Jump register indirect
	 * RET rA                       - (Pseudo-Instruction) Return from Subroutine (if rB=rZ+1)
	 *
	 * +------+------+------+------+
	 * | 0x09 |  (0) | rB   | rA   |
	 * +------+------+------+------+
	*/
	.macro DMACU.JMP.REG rB, rA
	DMACU.INST 0x09, 0x00, (\rB), (\rA)
	.endm

	.macro DMACU.RET rA
	DMACU.INST 0x09, 0x00, ((\rA) + 1), (\rA)
	.endm

	/*
	 * BNE (+off8) rZ, rB                   - Branch if not equal
	 *
	 * +------+------+------+------+
	 * | 0x0A |  rZ  | rB   | off8 |
	 * +------+------+------+------+
	 */
	.macro DMACU.BNE.REG tgt, rZ, rB
	DMACU.INST.BRANCH.REL 0x0A, (\rZ), (\rB), (\tgt)
	.endm

	/*
	 * BEQ (+off8) rZ, rB                   - Branch if equal
	 *
	 * +------+------+------+------+
	 * | 0x0B |  rZ  | rB   | off8 |
	 * +------+------+------+------+
	 */
	.macro DMACU.BEQ.REG tgt, rZ, rB
	DMACU.INST.BRANCH.REL 0x0B, (\rZ), (\rB), (\tgt)
	.endm

	/*
	 * BNE (+off8) rZ, #imm8                - Branch if not equal
	 *
	 * +------+------+------+------+
	 * | 0x0C |  rZ  | imm8 | off8 |
	 * +------+------+------+------+
	 */
	.macro DMACU.BNE tgt, rZ, imm8
	DMACU.INST.BRANCH.REL 0x0C, (\rZ), (\imm8), (\tgt)
	.endm

	/*
	 * BEQ (+off8) rZ, #imm8                - Branch if equal
	 *
	 * +------+------+------+------+
	 * | 0x0D |  rZ  | imm8 | off8 |
	 * +------+------+------+------+
	 */
	.macro DMACU.BEQ tgt, rZ, imm8
	DMACU.INST.BRANCH.REL 0x0D, (\rZ), (\imm8), (\tgt)
	.endm

	/*
	 * NOT rZ, rB                      - Bitwise NOT
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x0E |  rZ  | rB   | (0)  |
	 * +------+------+------+------+
	 */
	.macro DMACU.NOT rZ, rB
	DMACU.INST 0x0E, (\rZ), (\rB), 0
	.endm

	/*
	 * AND rZ, rB, rA                  - Bitwise AND
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x0F |  rZ  | rB   | rA   |
	 * +------+------+------+------+
	 */
	.macro DMACU.AND rZ, rB, rA
	DMACU.INST 0x0F, (\rZ), (\rB), (\rA)
	.endm

	/*
	 * OR  rZ, rB, rA                  - Bitwise OR
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x10 |  rZ  | rB   | rA   |
	 * +------+------+------+------+
	 */
	.macro DMACU.OR rZ, rB, rA
	DMACU.INST 0x10, (\rZ), (\rB), (\rA)
	.endm

	/*
	 * EOR rZ, rB, rA                  - Bitwise XOR
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x11 |  rZ  | rB   | rA   |
	 * +------+------+------+------+
	 */
	.macro DMACU.EOR rZ, rB, rA
	DMACU.INST 0x11, (\rZ), (\rB), (\rA)
	.endm

	/*
	 * ROR rZ, rB, #1                  - Rotate-Right by 1
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x12 |  rZ  | rB   | (0)  |
	 * +------+------+------+------+
	 */
	.macro DMACU.ROR1 rZ, rB
	DMACU.INST 0x12, (\rZ), (\rB), 0
	.endm

	/*
	 * ROL rZ, rB, #1                  - Rotate-Left by 1
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x13 |  rZ  | rB   | (0)  |
	 * +------+------+------+------+
	 */
	.macro DMACU.ROL1 rZ, rB
	DMACU.INST 0x13, (\rZ), (\rB), 0
	.endm

	/*
	 * LO4 rZ, rB                      - Extract lower 4 bits
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x14 |  rZ  | rB   | (0)  |
	 * +------+------+------+------+
	*/
	.macro DMACU.LO4 rZ, rB
	DMACU.INST 0x14, (\rZ), (\rB), 0
	.endm

	/*
	 * HI4 rZ, rB                      - Extract upper 4 bits
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x15 |  rZ  | rB   | (0)  |
	 * +------+------+------+------+
	 */
	.macro DMACU.HI4 rZ, rB
	DMACU.INST 0x15, (\rZ), (\rB), 0
	.endm

	/*
	 * SHL4 rZ, rB                     - Shift left by 4 bits
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x16 |  rZ  | rB   | (0)  |
	 * +------+------+------+------+
	 */
	.macro DMACU.SHL4 rZ, rB
	DMACU.INST 0x16, (\rZ), (\rB), 0
	.endm

	/*
	 * JAL rZ+1:rZ, #imm16             - Jump and Link
	 *
	 *  31  24     16      8      0
	 * +------+------+-------------+
	 * | 0x17 |  rZ  | imm16       |
	 * +------+------+-------------+
	 */
	.macro DMACU.JAL rZ, tgt
	DMACU.INST.JMP.ABS 0x17, (\rZ), (\tgt)
	.endm

	/*
	 * LIT32 rZ+3:rZ+2:rZ+1:rZ, (off16) - Load a 32-bit literal
	 *
	 *  31  24     16      8      0
	 * +------+------+-------------+
	 * | 0x18 |  rZ  | (off16)     |
	 * +------+------+-------------+
	 */
	.macro DMACU.LIT32 rZ, tgt
	DMACU.OP1.IMM16 0x18, (\rZ), ((\tgt) - DMACU_Code)
	.endm

	/*
	 * LDB rZ, [rB+1:rB:rA+1:rA]        - Load byte indirect
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x19 |  rZ  | rB   | rA   |
	 * +------+------+------+------+
	 */
	.macro DMACU.LDB rZ, rB, rA
	DMACU.INST 0x19, (\rZ), (\rB), (\rA)
	.endm

	/*
	 * LDH rZ+1:rZ, [rB+1:rB:rA+1:rA]    - Load half-word indirect
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x1B |  rZ  | rB   | rA   |
	 * +------+------+------+------+
	 */
	.macro DMACU.LDH rZ, rB, rA
	DMACU.INST 0x1B, (\rZ), (\rB), (\rA)
	.endm

	/*
	 * LDW rZ+3:rZ+2:rZ+1:rZ, [rB+1:rB:rA+1:rA]    - Load word indirect
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x1D |  rZ  | rB   | rA   |
	 * +------+------+------+------+
	 */
	.macro DMACU.LDW rZ, rB, rA
	DMACU.INST 0x1D, (\rZ), (\rB), (\rA)
	.endm

	/*
	 * STB rZ, [rB+1:rB:rA+1:rA]        - Store byte indirect
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x1A |  rZ  | rB   | rA   |
	 * +------+------+------+------+
	 */
	.macro DMACU.STB rZ, rB, rA
	DMACU.INST 0x1A, (\rZ), (\rB), (\rA)
	.endm

	/*
	 * STH rZ+1:rZ, [rB+1:rB:rA+1:rA]    - Store half-word indirect
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x1C |  rZ  | rB   | rA   |
	 * +------+------+------+------+
	*/
	.macro DMACU.STH rZ, rB, rA
	DMACU.INST 0x1C, (\rZ), (\rB), (\rA)
	.endm

	/*
	 * STW rZ+3:rZ+2:rZ+1:rZ, [rB+1:rB:rA+1:rA]    - Store word indirect
	 *
	 *  31  24     16      8      0
	 * +------+------+------+------+
	 * | 0x1E |  rZ  | rB   | rA   |
	 * +------+------+------+------+
	 */
	.macro DMACU.STW rZ, rB, rA
	DMACU.INST 0x1E, (\rZ), (\rB), (\rA)
	.endm

	/*
	 * UND #imm24 - Undefined Instruction
	 *
	 *  31     24     16      8      0
	 * +---------+------+------+------+
	 * | 0x1F(*) | (0)  | (0)  | (0)  |
	 * +---------+------+------+------+
	 *
	 * (*) Canonical encoding of the undefined instruction
	 *
	 * The UND instruction (or any other undefined instruction encoding) writes the special
	 * value 0xDEADC0DE to the Cpu_NextPC descriptor and terminates further DMA processing
	 * (by linking to the NULL descriptor). The instruction itself (and its 24-bit immediate
	 * operand) are retained in the Cpu_CurrentOPC register and can be used for debugging
	 * purposes (from the host system).
	 */
	.macro DMACU.UND rZ, imm24=0
	DMACU.INST 0x1F, (((\imm24)>>16)&0xFF), (((\imm24)>>8)&0xFF), (((\imm24)>>0)&0xFF)
	.endm

	/*******************************************************************************************
	 * Bootstrap code for QEMU's versatilepb emulation
	 ******************************************************************************************/
#if QEMU_BOOTSTRAP
	.arch armv5t
	.equ PL080_DMA_BASE_ADDR,        0x10130000
	.equ PL080_DMA_CH0_OFFSET,       0x100
	.equ PL080_DMA_CH_ENABLE_OFFSET, 0x110
	.equ PL080_DMA_ENABLE_OFFSET,    0x030
#endif

#if QEMU_BOOTSTRAP
	/*
	 * ARM GCC linker scripts commonly place ".text.startup" before ".text"; we exploit this to
	 * place our reset vector table at the beginning (without a lot of hassle)
	 */
	//.pushsection ".text.startup", "ax", "progbits"
	.text
	.global _start
	.p2align 2
	.arm
_start:	B Reset_Handler
	B .
	B .
	B .
	B .
	B .
	B .
	B .
	B .
	B .
	B .
	B .
	B .
	B .
	B .
	B .
	.type _start, "function"
	.size _start, . - _start
	.popsection

	//.pushsection ".text", "ax", "progbits"
	.global Reset_Handler
	.p2align 2
	.arm
Reset_Handler:
	// TODO: Scatter-Load .data segment (not needed for QEMU; would be needed for HW)

	// Load the bootstrap config
	ADR  r0, Bootstrap_Config
	LDM  r0, {r4-r8}

	// Set the start address of the DMACU program
	//
	// THIS SHOULD BE: STR  r4, [r6]
	// We accidentially produced: STR r4, [r5]
	STR r4, [r5]

	// Enable the PL080 DMA controller
	LDR  ip, [r8, #PL080_DMA_ENABLE_OFFSET]
	ORRS ip, ip, #1
	STR  ip, [r8, #PL080_DMA_ENABLE_OFFSET]

	// Configure DMA channel #0
	LDM  r4, {r0-r3} // bug: should have been LDM r5, [...]
	STR  r0, [r8, #PL080_DMA_CH0_OFFSET + 0x0]
	STR  r1, [r8, #PL080_DMA_CH0_OFFSET + 0x4]
	STR  r2, [r8, #PL080_DMA_CH0_OFFSET + 0x8]
	STR  r3, [r8, #PL080_DMA_CH0_OFFSET + 0xC]

	// Start channel #0
	LDR  ip, [r8, #PL080_DMA_CH_ENABLE_OFFSET]
	MOVS ip, #1
	STR  ip, [r8, #PL080_DMA_CH_ENABLE_OFFSET]

	// Wait until the DMA tranfer is done (i.e. until DMACU has halted)
WaitForDma:
	LDR  ip, [r8, #PL080_DMA_CH_ENABLE_OFFSET]
	ANDS ip, ip, #1
	BNE  WaitForDma

	// DMA transfer is done; signal a semihosting halt
	MOV r0, #0x18    // SYS_EXIT
	LDR r1, =0x20026 // Application exit
	SVC #0x123456

	// Should not be here
	B .

	.ltorg

	.p2align 2
Bootstrap_Config:
	.long DMACU_Code          // r4 - Address of the DMACU program
	.long Dma_UCode_CPU       // r5 - First DMA descriptor of the DMACU microcode
	.long Cpu_PC              // r6 - Pointer to DMACU's program counter
	.long Cpu_NextPC          // r7 - Pointer to DMACU's next instruction address
	.long PL080_DMA_BASE_ADDR // r8 - PL080 Base Address

	.type Reset_Handler, "function"
	.size Reset_Handler, . - Reset_Handler
	.popsection
#endif

	/*******************************************************************************************
	 * Here Comes the Hello World Program (running on the virtual "DMACU" CPU on the PL080 DMA)
	 ******************************************************************************************/

	/*
	 * Code segment of the DMACU program
	 *
	 * We require alignment on a 16-bit boundary to allow for the full 64K of program space
	 * (reachable via the test program)
	 */
	.pushsection ".rodata", "a", "progbits"
	.global DMACU_Code
	.p2align 16
DMACU_Code:
	.equ kPeriphBase,    0   // r1:r0 - PL011 Peripheral Base Address     (0x101F____)
	.equ kUartDataReg,   2   // r3:r2 - Offset of the PL011 Data Register (0x____1000)
	.equ kUartFlagReg,   4   // r5:r4 - Offset of the PL011 Flag Register (0x____1018)

	.equ cstUartTxReadyFlag, 0x80

	.equ rCurrent,     128   // r131:r130:r129:r128 - Current string pointer
	.equ rByte,        132   // r132                - Current Data Byte (Value)

	.equ rLink,        254   // r255:r254 - Link Register
	.equ rTmp8,        253   // Used by PrintByte to preserve the link register und subroutine calls and to poll the UART
	.equ rTmp7,        252   // Used by PrintByte to preserve the link register und subroutine calls and to poll the UART
	.equ rTmp6,        251   // Used by PrintByte to poll the UART
	.equ rTmp5,        250   // Used by PrintByte to poll the UART

	.equ rTmp4,        249
	.equ rTmp3,        248   // Used by IncrementCurrent for carry
	.equ rTmp2,        247   // Used by IncrementCurrent for carry
	.equ rTmp1,        246   // Used by IncrementCurrent for carry
	.equ rTmp0,        245   // Used by IncrementCurrent for carry

	// Initialize the UART data register
	DMACU.MOV.IMM16  kPeriphBase,  0x101F
	DMACU.MOV.IMM16  kUartDataReg, 0x1000

	// Load the pointer to our string
	DMACU.LIT32 rCurrent, HelloWorldPtr

PrintByteLoop:
	DMACU.LDB  rByte, rCurrent+2, rCurrent  // Load next byte
	DMACU.BEQ  ProgramDone, rByte, 0      // We are done if we reached '\0'
	DMACU.JAL  rLink, PrintByte           // Jump to print byte subroutine
	DMACU.JMP  PrintByteLoop              // Loop

	// Done
ProgramDone:
	DMACU.UND  0x00DEAD
	DMACU.JMP  ProgramDone

HelloWorldPtr:
	.long HelloWorldString

PrintByte:
	// Wait until the UART is ready to transmit
	DMACU.LDW       rTmp5, kPeriphBase, kUartFlagReg
	DMACU.MOV.IMM8  rTmp6, cstUartTxReadyFlag
	DMACU.AND       rTmp5, rTmp6, rTmp6
	DMACU.BEQ       PrintByte, rTmp5, 0

	// Copy a byte from source to UART
	DMACU.LDB  rByte, rCurrent+2, rCurrent
	DMACU.STB  rByte, kPeriphBase, kUartDataReg

	// Preserve link reg during call the IncrementCurrent, then increment the current pointer
	DMACU.MOV2 rTmp7, rLink+1, rLink
	DMACU.JAL  rLink, IncrementCurrent
	DMACU.MOV2 rLink, rTmp7+1, rTmp7

	// Return
	DMACU.RET rLink

	// Increment rCurrent (32-bit increment)
IncrementCurrent:
	// 32-bit "ripple" increment
	DMACU.ACY.IMM8 rTmp0,    rCurrent,    1
	DMACU.ADD.IMM8 rCurrent, rCurrent,    1
	DMACU.ACY rTmp1,        (rCurrent+1), rTmp0
	DMACU.ADD (rCurrent+1), (rCurrent+1), rTmp0
	DMACU.ACY rTmp2,        (rCurrent+2), rTmp1
	DMACU.ADD (rCurrent+2), (rCurrent+2), rTmp1
	DMACU.ADD (rCurrent+2), (rCurrent+2), rTmp2

	DMACU.RET rLink

	.type DMACU_Code, "object"
	.size DMACU_Code, . - DMACU_Code
	.popsection

	.pushsection ".rodata", "a", "progbits"
HelloWorldString:
	.asciz "Hello from a DMA World!\n"
	.popsection
